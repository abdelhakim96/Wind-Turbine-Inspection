@###############################################
@#
@# PX4 ROS compatible message source code
@# generation for C++
@#
@# EmPy template for generating <msg>.h files
@# Based on the original template for ROS
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@#  - search_path (dict) search paths for genmsg
@#  - topics (List of String) multi-topic names
@###############################################
/****************************************************************************
 *
 *   Copyright (C) 2013-2016 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/* Auto-generated by genmsg_cpp from file @file_name_in */

@{
import genmsg.msgs
import gencpp
from px_generate_uorb_topic_helper import * # this is in Tools/

uorb_struct = '%s_s'%spec.short_name
topic_name = spec.short_name
}@

#include <px4_config.h>
#include <microcdr/microCdr.h>
#include <uORB/topics/@(topic_name).h>
#include <uORB_microcdr/topics/@(topic_name).h>

@#################################################
@# Searching for serialize function per each field
@#################################################
@{

def print_info(field):
    print("type: ", field.type, "name: ", field.name, "base_type: ", \
          field.base_type, "field.is_array:", ('0', '1')[field.is_array], " array_len: ", field.array_len, \
          "is_builtin:", ('0', '1')[field.is_builtin], "is_header:", ('0', '1')[field.is_header])

def print_level_info(fields):
    for field in fields:
        print_info(field)
        if (not field.is_builtin):
            print("\n")
            children_fields = get_children_fields(field.base_type, search_path)
            print_level_info(children_fields)
            print("\n")

def walk_through_parsed_fields():
    print_level_info(spec.parsed_fields())

def get_serialization_type_name(type_name):
    if type_name in type_serialize_map:
        return type_serialize_map[type_name]
    else:
        raise Exception("Type {0} not supported, add to type_serialize_map!".format(type_name))

def add_serialize_functions(fields, scope_name):
    for field in fields:
        if (not field.is_header):
            if (field.is_builtin):
                if (not field.is_array):
                    print("    serialize"+str(get_serialization_type_name(field.type))+"(input->"+scope_name+str(field.name)+", microCDRWriter);")
                else:
                    print("    serialize"+str(get_serialization_type_name(field.base_type))+"Array(input->"+scope_name+str(field.name)+", "+str(field.array_len)+", microCDRWriter);")
            else:
                name = field.name
                children_fields = get_children_fields(field.base_type, search_path)
                if (scope_name):  name = scope_name + name
                if (not field.is_array):
                    add_serialize_functions(children_fields, name + '.')
                else:
                    for i in range(field.array_len):
                        add_serialize_functions(children_fields, name + ('[%d].' %i))

def add_deserialize_functions(fields, scope_name):
    for field in fields:
        if (not field.is_header):
            if (field.is_builtin):
                if (not field.is_array):
                    print("    deserialize"+str(get_serialization_type_name(field.type))+"(&output->"+scope_name+str(field.name)+", microCDRReader);")
                else:
                    for i in range(field.array_len):
                        print("    deserialize"+str(get_serialization_type_name(field.base_type))+"(&output->"+scope_name+str(field.name)+ str('[%d]' %i) +", microCDRReader);")
            else:
                name = field.name
                children_fields = get_children_fields(field.base_type, search_path)
                if (scope_name):  name = scope_name + name
                if (not field.is_array):
                    add_deserialize_functions(children_fields, name + '.')
                else:
                    for i in range(field.array_len):
                        add_deserialize_functions(children_fields, name + ('[%d].' %i))

def add_code_to_serialize():
    # sort fields (using a stable sort) as in the declaration of the type
    sorted_fields = sorted(spec.parsed_fields(), key=sizeof_field_type, reverse=True)
    add_serialize_functions(sorted_fields, "")

def add_code_to_deserialize():
    # sort fields (using a stable sort) as in the declaration of the type
    sorted_fields = sorted(spec.parsed_fields(), key=sizeof_field_type, reverse=True)
    add_deserialize_functions(sorted_fields, "")
}@

void serialize_@(topic_name)(const struct @(uorb_struct) *input, char *output, uint32_t *length, struct microCDR *microCDRWriter)
{
    if (nullptr == input || nullptr == output || nullptr == length || nullptr == microCDRWriter) return;

    resetStaticMicroCDRForSerialize(microCDRWriter);

    serializeUnsignedLong(input->timestamp, microCDRWriter);
@add_code_to_serialize()

    (*length) = microCDRWriter->m_microBuffer->m_serializedBuffer;
}

void deserialize_@(topic_name)(struct @(uorb_struct) *output, char *input, struct microCDR *microCDRReader)
{
    if (nullptr == output || nullptr == input || nullptr == microCDRReader) return;

    resetStaticMicroCDRForDeserialize(microCDRReader);

    deserializeUnsignedLong(&output->timestamp, microCDRReader);
@add_code_to_deserialize()
}